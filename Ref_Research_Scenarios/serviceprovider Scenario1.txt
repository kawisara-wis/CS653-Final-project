//service/provider Scenario1


const Provider = require('../models/Provider');
// (วางไว้ใกล้ๆ const Provider = ...)
const Account = require('../models/Account');

exports.Provider = Provider;

const serviceService = require("./Service");
const serviceConsumer = require("./Consumer");
const serviceOfferCapacity = require("./OfferCapacity");
const servicePoolCapacity = require("./PoolCapacity");

// --- เพิ่ม 3 บรรทัดนี้ ---
const axios = require('axios');
const path = require('path');
require('dotenv').config(); // ใช้สำหรับโหลด .env
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
// --- สิ้นสุดส่วนที่เพิ่ม ---

const logger = require('../utils/logger');
const serviceOfferDirect = require("./OfferDirect");

// (นี่คือเวอร์ชันที่ถูกต้อง - สังเกต (account, options = {}))
exports.create = (account, options = {}) => {
    return new Promise(async (resolve, reject) => {
        try {
            logger.silly("serviceProvider.create() called with: accountId: " + account.id);
            //Reject if account not defined
            if (!account) throw ("Account not defined");

            let provider = new Provider({
                account: account._id,
                // บรรทัดนี้จะทำงานถูกต้อง เพราะ 'options' ถูกกำหนดไว้ด้านบนแล้ว
                agentType: options.agentType || 'random' 
            });

            await provider.save();
            logger.info(`serviceProvider.create() created provider with providerId: ${provider.id} (Type: ${provider.agentType})`);
            resolve(provider);
        } catch (e) {
            logger.error("serviceProvider.create() error: " + e);
            reject(e);
        }
    })
}

exports.offerDirectReceive = (provider, offerDirect) => {
    return new Promise(async (resolve, reject) => {
        try {
            logger.silly("serviceProvider.offerDirectReceived() called with offerDirect: " + offerDirect._id);
            //Reject if offer not defined
            if (!offerDirect) {
                logger.error("serviceProvider.offerDirectReceived() error: Offer direct not defined");
                return reject("Offer direct not defined");
            }
            //Reject if offer not in state MARKET
            if (offerDirect.state !== "MARKET") {
                logger.error("serviceProvider.offerDirectReceived() error: Offer direct not in state MARKET");
                return reject("Offer direct not in state MARKET");
            }
            if (!provider) {
                logger.error("serviceProvider.offerDirectReceived() error: Provider not found");
                return reject("Provider not found");
            }
            let decision = await decisionOfferDirect(provider, offerDirect);
            //Get consumer that created offerDirect via account
            let consumer = await serviceConsumer.Consumer.findOne({account: offerDirect.seller});
            if (!consumer) {
                logger.error("serviceProvider.offerDirectReceived() error: Consumer not found");
                return reject("Consumer not found");
            }
            //TODO: Remove from testing
            // decision = "postpone";

            switch (decision) {
                // (นี่คือโค้ดใหม่สำหรับ "case accept")
                case "accept": {
                    // --- 1. ค้นหา Account (บัญชี) ของทั้งสองฝ่าย ---
                    let providerAccount = await Account.findById(provider.account);
                    let consumerAccount = await Account.findById(offerDirect.seller);
                    let price = offerDirect.price;

                    if (!providerAccount || !consumerAccount) {
                        let errorMsg = "Account not found for transaction";
                        logger.error(errorMsg);
                        throw new Error(errorMsg);
                    }

                    // --- 2. ทำการโอนเงิน (อัปเดต Balance) ---
                    consumerAccount.balance -= price;
                    providerAccount.balance += price;

                    // --- 3. บันทึกการเปลี่ยนแปลงลงฐานข้อมูล ---
                    await consumerAccount.save();
                    await providerAccount.save();
    
                    logger.info(`TRANSACTION: Provider ${provider._id} earned ${price}. New balance: ${providerAccount.balance}`);
                    logger.info(`TRANSACTION: Consumer ${consumer.id} spent ${price}. New balance: ${consumerAccount.balance}`);

                    // --- 4. โค้ดเดิม (ทำงานต่อ) ---
                    offerDirect = await serviceConsumer.offerDirectAccepted(consumer, offerDirect);
                    logger.silly("serviceProvider.offerDirectReceived() accepted offer direct: " + offerDirect.id);
                    
                    let service = await serviceService.Service.findById(offerDirect.service);
                    
                    service.provider = provider._id; // ระบุว่าใครเป็นคนทำงานนี้
                    await service.save();            // บันทึกลงฐานข้อมูล

                    logger.silly("serviceProvider.offerDirectReceived() commence service: " + service.id);
                    await serviceService.commence(service);
                    logger.silly("serviceProvider.offerDirectReceived() commenced service: " + service.id);
                }
                break;
                case "reject":{
                    offerDirect = await serviceConsumer.offerDirectRejected(offerDirect);
                    logger.silly("serviceProvider.offerDirectReceived() rejected offer direct: " + offerDirect._id);
                }
                    break;
                case "postpone":{
                    logger.silly("serviceProvider.offerDirectReceived() postponed offer direct: " + offerDirect._id);
                    let offerCapacity = await serviceOfferCapacity.create(offerDirect, clcOfferCapacityPrice(offerDirect), clcOfferCapacityExpiryTimestamp(offerDirect));                 logger.silly("serviceProvider.offerDirectReceived() created offer capacity: " + offerCapacity._id);
                    await servicePoolCapacity.offerCapacityPost(offerCapacity);
                    logger.info("servicePoolCapacity.offerCapacityPost() posted offer capacity: " + offerCapacity._id);
                }
            }
            resolve(offerDirect);
        } catch (e) {
            logger.error("serviceProvider.offerDirectReceived() error: " + e);
            reject(e);
        }
    })
}

exports.offerCapacityAccepted = (provider, offerCapacity) => {
    return new Promise(async (resolve, reject) => {
        try {
            logger.silly("serviceProvider.offerCapacityAccepted() called with offerCapacity: " + offerCapacity._id);
            //Reject if offer not defined
            if (!offerCapacity) {
                logger.error("serviceProvider.offerCapacityAccepted() error: Offer capacity not defined");
                return reject("Offer capacity not defined");
            }
            //Reject if provider not defined
            if (!provider) {
                logger.error("serviceProvider.offerCapacityAccepted() error: Provider not found");
                return reject("Provider not found");
            }
            //Reject if offer not in state ACCEPTED
            if (offerCapacity.state !== "ACCEPTED") {
                logger.error("serviceProvider.offerCapacityAccepted() error: Offer capacity not in state ACCEPTED");
                return reject("Offer capacity not in state ACCEPTED");
            }
            //Get offerDirect from offerCapacity
            let offerDirect = await serviceOfferDirect.OfferDirect.findById(offerCapacity.offerDirect);
            if (!offerDirect) {
                logger.error("serviceProvider.offerCapacityAccepted() error: Offer direct not found");
                return reject("Offer direct not found");
            }
            //Notify consumer that offer direct has been accepted
            let consumer = await serviceConsumer.Consumer.findOne({account: offerDirect.seller});
            if (!consumer) {
                logger.error("serviceProvider.offerCapacityAccepted() error: Consumer not found");
                return reject("Consumer not found");
            }
            offerDirect = await serviceConsumer.offerDirectAccepted(consumer, offerDirect);
            resolve(offerDirect);
        } catch (e) {
            logger.error("serviceProvider.offerCapacityAccepted() error: " + e);
            reject(e);
        }
    })

}

exports.offerCapacityPosted = (provider, offerCapacity) => {
    return new Promise(async (resolve, reject) => {
            try {
                logger.silly("serviceProvider.offerCapacityReceived() called with offerCapacity: " + offerCapacity._id);
                //Reject if offer not defined
                if (!offerCapacity) {
                    logger.error("serviceProvider.offerCapacityReceived() error: Offer capacity not defined");
                    return reject("Offer capacity not defined");
                }
                //Reject if provider not defined
                if (!provider) {
                    logger.error("serviceProvider.offerCapacityReceived() error: Provider not found");
                    return reject("Provider not found");
                }
                //Break if offer capacity is expired
                if (offerCapacity.expiryTimestamp < Date.now()) {
                    logger.silly("serviceProvider.offerCapacityReceived() offer capacity expired: " + offerCapacity._id);
                    return resolve();
                }
                //Break if offer capacity not in state MARKET
                if (offerCapacity.state !== "MARKET") {
                    logger.silly("serviceProvider.offerCapacityReceived() offer capacity not in state MARKET: " + offerCapacity._id);
                    return resolve();
                }
                let decision = await decisionOfferCapacity(provider, offerCapacity);

                //TODO: Remove from testing
                // decision = "accept";

                if (decision === "accept") {
                    //Respond to offer capacity seller
                    let seller = await Provider.findOne({account: offerCapacity.seller});
                    //Accept offer capacity
                    offerCapacity.state = "ACCEPTED";
                    offerCapacity.buyer = provider.account;
                    await offerCapacity.save();
                    logger.silly("serviceProvider.offerCapacityReceived() accepted offer capacity: " + offerCapacity._id);
                    await this.offerCapacityAccepted(seller, offerCapacity);
                }
                resolve(offerCapacity);
            } catch (e) {
                logger.error("serviceProvider.offerCapacityReceived() error: " + e);
                reject(e);
            }
        }
    )

}

// (นี่คือฟังก์ชัน getLLMDecision เวอร์ชันแก้ไขสมบูรณ์)

async function getLLMDecision(provider, offer) {
    logger.info(`[AI Agent ${provider._id}] กำลังเรียก LLM (GPT-3-Turbo)...`);

    // 1. ค้นหา Service (เหมือนเดิม)
    let service = await serviceService.Service.findById(offer.service);
    let activeServices = await serviceService.Service.countDocuments({provider: provider._id, state: "ACTIVE"});
    const freeSlots = provider.servicesLimit - activeServices;

    // (วางโค้ดนี้ก่อน const context)

    // --- 1. ค้นหา "Services" ทั้งหมดที่ Provider คนนี้เคยรับ ---
    const providerServices = await serviceService.Service.find({
        provider: provider._id // ค้นหา Services ที่มี provider ID นี้
    }).select('_id'); // เราต้องการแค่ ID ของ Service

    // แปลงผลลัพธ์ [ {_id: ...}, ... ] ให้เป็นอาร์เรย์ของ ID [ ..., ... ]
    const serviceIds = providerServices.map(s => s._id);

    // --- 2. Query ประวัติ (History) ที่ถูกต้อง ---
    // ค้นหา 10 Offers ล่าสุดที่ "ACCEPTED" และ "เชื่อมโยง" กับ Service ของเรา
    const pastAcceptedOffers = await serviceOfferDirect.OfferDirect.find({
        service: { $in: serviceIds }, // ค้นหา Offer ที่อยู่ใน Service ID เหล่านี้
        state: 'ACCEPTED'
    })
    .sort({ createdAt: -1 }) // เรียงจากใหม่สุด
    .limit(10);              // เอาแค่ 10 อัน

    // --- 3. สร้าง "บทสรุป" (Summary) (โค้ดนี้เหมือนเดิม) ---
    let historySummary = {
        count_accepted: pastAcceptedOffers.length,
        avg_price: 0,
    };

    if (pastAcceptedOffers.length > 0) {
        const sum = pastAcceptedOffers.reduce((acc, offer) => acc + offer.price, 0);
        // คำนวณ "ราคาเฉลี่ย" ที่ AI เคยรับงาน
        historySummary.avg_price = parseFloat((sum / pastAcceptedOffers.length).toFixed(2));
    }


    // 4. สร้าง Context (เหมือนเดิม)
    const context = {
        free_slots: freeSlots,
        total_slots: provider.servicesLimit,
        offer_history: historySummary, // <-- ใส่ "บทสรุป" (Summary) ใหม่
        current_offer: {
            price: offer.price,
            duration: service.duration
        }
    };

    // 5. สร้าง Instructions (คำสั่ง) (สำหรับ Scenario 1&2 - No Pool)
    const instructions = `You are a warehouse agent operating in a shared warehouse system WITH NO POOL. Your goal is to maximize profits while efficiently utilizing storage slots. Based on the provided context, decide what action to take. Options: ['accept', 'reject']`;
    
    // 5. สร้าง Instructions (คำสั่ง) (สำหรับ Scenario 3&4 - มี Pool)
    //const instructions = `You are a warehouse agent operating in a shared warehouse system. Your goal is to maximize profits while efficiently utilizing storage slots. Based on the provided context, decide what action to take. Options: ['accept', 'reject', 'forward']`;
    const promptPayload = { context: context, instructions: instructions };

    try {
        // 6. ยิง API (ใช้ GPT-4o ตามที่คุณตั้งใจ)
        const response = await axios.post('https://api.openai.com/v1/chat/completions', {
            model: "gpt-3.5-turbo", // <-- ใช้ GPT-4o
            messages: [
                { role: "system", content: instructions },
                { role: "user", content: JSON.stringify(promptPayload, null, 2) }
            ],
            temperature: 0.5,
            max_tokens: 50
        }, {
            headers: { 'Authorization': `Bearer ${OPENAI_API_KEY}` }
        });

        const decisionText = response.data.choices[0].message.content.toUpperCase();
        logger.info(`[AI Agent ${provider._id}] LLM ตอบว่า: ${decisionText}`);

        // 7. แปลผลลัพธ์ (สำหรับ Scenario 1&2 เวอร์ชัน No Pool)
        if (decisionText.includes("ACCEPT")) { // 1&2
            return "accept"; // 1&2
        //} //1&2
        //(ในฟังก์ชัน getLLMDecision, ส่วน try...catch)

        // 7. แปลผลลัพธ์ (สำหรับ Scenario 3&4 เวอร์ชัน "มี Pool")
        //if (decisionText.includes("ACCEPT")) { // 3&4
        //    return "accept"; // สำหรับ Scenario 3 & 4 (มี Pool)
        } //3&4
        //if (decisionText.includes("FORWARD")) { // 3&4
        //    return "postpone"; // 3&4 "forward" ใน AI = "postpone" (ส่งต่อ) ในโค้ด
        //} //3&4

        // ถ้า AI ตอบ "REJECT" หรือตอบอย่างอื่น
        return "reject"; // สำหรับ Scenario 1&2&3&4 (No Pool)
         // ถ้า AI ตอบ "FORWARD" (เพราะมันถูกเทรนมา) หรือ "REJECT" ให้ถือเป็น "reject" // สำหรับ Scenario 4 (มี Pool)

    } catch (error) {
        logger.error(`[AI Agent ${provider._id}] LLM Error:`, error.response ? error.response.data.error : error.message);
        return "reject"; // ถ้า API พัง ให้ reject
    }
}

// แทนที่ฟังก์ชัน decisionOfferDirect เดิมทั้งหมดด้วยอันนี้
let decisionOfferDirect = (provider, offerDirect) => {
    return new Promise(async (resolve, reject) => {
        try {
            logger.silly("serviceProvider.decisionOfferDirect() called with offerDirect: " + offerDirect._id);

            // --- นี่คือ Logic ใหม่ที่เพิ่มเข้ามา ---
            if (provider.agentType === 'ai') {
                logger.silly(`Provider ${provider._id} is AI type. Calling LLM.`);
                let decision = await getLLMDecision(provider, offerDirect);
                return resolve(decision);
            }
            // --- จบ Logic ใหม่ ---

            // (ด้านล่างนี้คือ Logic เดิมสำหรับ 'random' agent)
            logger.silly(`Provider ${provider._id} is RANDOM type. Using random logic.`);
            //Do I have capacity to process service?
            //Get current number of services with state ACTIVE
            let count = await serviceService.Service.countDocuments({provider: provider._id, state: "ACTIVE"});
            if (count >= provider.servicesLimit) {
                logger.silly("serviceProvider.decisionOfferDirect() provider capacity reached: " + provider._id);
                return resolve(chooseOutcome(0.0, 0.1, 0.0)); // SC3&4 0,0.5,0.5 Hardcoded: 0% accept
            }                                               // SC1&2 0.0,1.0,0.0 (ถ้า Slot เต็ม: 0% accept, 100% reject, 0% postpone)

            let decision = chooseOutcome(0.5, 0.5, 0.0); // SC3&4 Hardcoded: 50% accept, 10% reject, 40% postpone
            if (decision === "accept") {               // SC1&2 50% accept, 50% reject, 0% postpone
                //Check the availability of the provider capacities
                //Get current number of services with state ACTIVE
                let count = await serviceService.Service.countDocuments({provider: provider._id, state: "ACTIVE"});
                if (count >= provider.servicesLimit) {
                    logger.silly("serviceProvider.decisionOfferDirect() provider capacity reached: " + provider._id);
                    decision = "reject";
                }
            }
            return resolve(decision);
        } catch (e) {
            logger.error("serviceProvider.decisionOfferDirect() error: " + e);
            reject(e);
        }
    })
}

let decisionOfferCapacity = (provider, offerCapacity) => {
    return new Promise(async (resolve, reject) => {
        try {
            logger.silly("serviceProvider.decisionOfferCapacity() called with offerCapacity: " + offerCapacity._id);
            //Is offer capacity seller me?
            if (offerCapacity.seller === provider.account) {
                logger.silly("serviceProvider.decisionOfferCapacity() offer capacity seller is me: " + provider.id);
                return resolve("postpone");
            }
            // Do I have capacity to process service?
            //Get current number of services with state ACTIVE
            let count = await serviceService.Service.countDocuments({provider: provider._id, state: "ACTIVE"});
            if (count >= provider.servicesLimit) {
                logger.silly("serviceProvider.decisionOfferCapacity() provider capacity reached: " + provider.id);
                return resolve("postpone");
            }
            return resolve(chooseOutcome(0.5, 0.5, 0.0)); // SC 1&2 : 50% accept, 50% reject, 0% postpone
                                                          // SC 3&4 0.5, 0.0, 0.5 
        } catch (e) {
            logger.error("serviceProvider.decisionOfferCapacity() error: " + e);
            reject(e);
        }
    })
}

let chooseOutcome = (acceptProbability, rejectProbability, postponeProbability) => {
    // Ensure the sum of probabilities is 1
    if (acceptProbability + rejectProbability + postponeProbability !== 1) {
        return 'Error: Probabilities must sum up to 1';
    }

    // Generate a random number between 0 and 1
    const randomNumber = Math.random();

    // Determine the outcome based on the probabilities
    if (randomNumber < acceptProbability) {
        return 'accept';
    } else if (randomNumber < acceptProbability + rejectProbability) {
        return 'reject';
    } else {
        return 'postpone';
    }
}

let clcOfferCapacityPrice=(offerDirect)=>{
    return offerDirect.price+1;
}

let clcOfferCapacityExpiryTimestamp=(offerDirect)=>{
    return offerDirect.expiryTimestamp-1;
}